
### for循环
`break`关键字只结束最内层的for循环，外层的for循环会继续运行。如果集合或迭代器中的元素是一个序列（比如元组或列表），它们可以在for循环语句中很方便地通过拆包成变量：

```
for a, b, c in iterator
```

### pass
`pass`就是Python中的“什么都不做”的语句，它用于在代码段中表示不执行任何操作（或者是作为还没有实现的代码占位符）；之所以需要它，是因为Python使用了缩进来分隔代码块

```
if x<0:
    print('negative!')
elif x==0:
    #在这里放点聪明的代码
    pass
else:
    print('positive!')
```

### range函数
range函数返回一个迭代器，该迭代器生成一个等差整数序列，起始、结尾、步进（可以是负的）可以作为三个参数传给range函数
![](https://upload-images.jianshu.io/upload_images/15777037-2bccef4a73ad7173.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
>range产生的整数包含起始但不包含结尾

### 三元表达式
Python中的三元表达式允许将if-else代码块联合起来，在一行代码或一个语句中生成数据
```
value = true-expr if condition else false-expr
```

此处的true-expr和false-expr可以是任意Python表达式

### 内建数据结构、函数及文件

#### 创建元组
1. 最简单的方法就是用逗号分隔序列值
```
tup=4,5,6
```

2. 使用`tuple`函数将任意序列或迭代器转换为元组
```
tuple([2,4,5])
tup = tuple('String')
```

#### 如何将元组串联
1. 不同元组之间的连接：通过使用`+`号将两个不同的元组连接生成更长的元组
![](https://upload-images.jianshu.io/upload_images/15777037-a36bb36b78a8e78e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
2. 相同元组之间的连接：使用元组乘以整数，则会和列表一样，生成含有多份拷贝的元组，请注意对象自身并没有复制，只是指向它们的引用进行复制

#### 元组拆包
如果你要将元组型的表达式赋值给变量，Python会对等号右边的值进行拆包：
![](https://upload-images.jianshu.io/upload_images/15777037-faeb902ec28aa629.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
拆包的一般场景就是遍历元组或列表组成的序列
![](https://upload-images.jianshu.io/upload_images/15777037-e26c89f548dce268.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
另一个场景是从函数返回多个值
另外Python语言中新增了一些更为高级的元组拆包功能，如语法`*rest`,该语法用于在函数调用时获取任意长度的位置参数列表，其中rest部分有时是你想要丢弃的数据，rest这个变量名并没有什么特殊之处，为了方便，常常有下划线（_）来表示不想要的变量
![](https://upload-images.jianshu.io/upload_images/15777037-c91813f629db137c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 元组方法
因为元组的大小和内容都不能修改，它的实例方法都很轻量，其中一个很有用的就是`count`(也适用于列表)，它可以统计某个值出现的频率
![](https://upload-images.jianshu.io/upload_images/15777037-9d02535293d5024d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 创建列表
1. 使用方括号定义
```
list = [2,3,4]
```

2. 利用`list`函数，将迭代器或其他类型的表达式转化为列表，同时list常常用来在数据处理中实体化生成器或迭代器
```
tup = (3,4,5)
lis = list(tup)
```

#### 列表增加、删除和检查元素
1. 增加的方法：使用`append`方法在列表末尾添加元素，`insert`方法在特定的位置插入元素（插入范围为0~列表长度之间）
 ![](https://upload-images.jianshu.io/upload_images/15777037-50f0de941e2c5773.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
>注意：与append相比，insert的耗费的计算量大，因为对后续元素的引用必须在内部迁移，以便为新元素提供空间。如果要在序列的头部和尾部插入元素，需使用`collections.deque`,一个双尾部队列

2. 删除的方法：`pop`是insert方法的逆运算，可以移除并返回指定位置的元素。`remove`方法会寻找第一个值并除去。
 ![](https://upload-images.jianshu.io/upload_images/15777037-cc646d437339cc66.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
 >如果不考虑性能，使用append和remove，可以把Python的列表当做完美的“多重集”数据结构。

3. 检查列表中是否包含某个值：`in`方法，`not in`为逆方法
![](https://upload-images.jianshu.io/upload_images/15777037-aa3e7afc9376cfc9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
>在列表中检查是否存在某个值远比字典和集合速度慢，因为Python是线性搜索列表中的值，但在字典和集合中，在同样的时间内还可以检查其它项（基于哈希表）。

#### 列表的串联和组合
1. 和元组类似，通过`+`号将两个列表串联起来
2. `extend`方法可以增加多个元素，效果和`+`号类似
![](https://upload-images.jianshu.io/upload_images/15777037-5c90c1ae24f323c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
>通过加法将列表串联的计算量较大，因为要新建一个列表，并且要复制对象。用extend追加元素，尤其是到一个大列表中，更为可取

#### 列表的排序:sort方法的参数使用
列表的sort方法没有什么特别的，就是对列表中的元素进行排序，这里要说的是sort方法的一些选项，其中之一是`二级排序Key`，下面我们按长度对字符串进行排序：
![](https://upload-images.jianshu.io/upload_images/15777037-ae51cdc6981dafa2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 列表中的二分搜索和已排序列表的插值
`bisect.bisect`会找到元素应当被插入的位置，并保持序列排序，而`bisect.insort`将元素排入到相应位置
![](https://upload-images.jianshu.io/upload_images/15777037-9af8aa6739191c0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
>注：bisect模块的函数并不会检查列表是否已经排序，因此对于未排序列表使用bisect的函数可能会导致不正确的结果。

#### 切片
切片的基本形式是`start:stop`切片可以对大多数的序列类型选取其子集，包括元组，列表等
![](https://upload-images.jianshu.io/upload_images/15777037-5db3feeb38f54fc8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
>注：stop的值可以设置为大于序列的边界值而不会报错

切片还可以将序列赋值给变量
![](https://upload-images.jianshu.io/upload_images/15777037-45edf3efea8108a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
切片的起始位置start的索引是包含的，而结束位置stop的索引并不包含，因此元素的数量是stop-start。
start和stop是可以省略的，这样默认传入序列的开始位置和结束位置
![](https://upload-images.jianshu.io/upload_images/15777037-626190de7a277b36.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
负值索引是从序列尾部进行索引
![](https://upload-images.jianshu.io/upload_images/15777037-58e17bcf3d0a9427.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
切片除了有start和stop两个参数，还有步进值step，这样的切片形式为`start:stop:step`，意思为每隔多少个数取一个值
![](https://upload-images.jianshu.io/upload_images/15777037-ffdb968c7fc141b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
小技巧：需要对列表或元组进行翻转时，可以将步进值设为-1
![](https://upload-images.jianshu.io/upload_images/15777037-65c11e08c0702dde.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### enumerate函数
该函数可以得到序列中，索引和值的对应元组（i,value），如下
```
for i , value in enumerate(collection)
```

#### sorted函数
该函数返回一个根据任意序列中的元素新建的已排序`列表`，其接受的参数和sort方法一致,与sort方法不同在于，该函数是新建一个已排序列表，而sort方法是在原列表基础上进行排序

#### zip函数
该函数将列表、元组或其他序列的元素配对，新建一个元组构成的列表
![](https://upload-images.jianshu.io/upload_images/15777037-e47fc780022b8320.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
>注：zip函数可以将不同类的序列进行合并，如元组和列表，如上图

zip支持任意多的序列，元素的个数取决于最短的序列
![](https://upload-images.jianshu.io/upload_images/15777037-cc32739761bba405.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
给出一个“被压缩的”序列，zip可以被用来解压序列。也可以当作把行的列表转换为列的列表。这个方法看起来有点神奇：
![](https://upload-images.jianshu.io/upload_images/15777037-f57315edc0cdd79e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### reserved函数
该函数从后向前迭代一个序列
![](https://upload-images.jianshu.io/upload_images/15777037-48596c0c4197e191.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
>注：`reserved`是一个生成器，只有实体化（即列表或for循环）之后才能创建翻转的序列（生成器是迭代器的子类）

#### 如何判断可迭代对象（Iterable）和迭代器(Iterator)
可以使用`isinstance`函数进行判断，各种集合数据类型（列表、元组、字典）都是可迭代对象
![](https://upload-images.jianshu.io/upload_images/15777037-097c759bda7091fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 如何创建、访问、插入、设定、删除、联合字典
字典是Python中最为重要的数据结构，也被称为哈希映射或关联数组，它是键值对的大小可变集合。创建字典的方法：
1. 使用尖括号直接创建，然后可以像访问列表或元组中的元素一样，访问、插入或设定字典中的元素：
![](https://upload-images.jianshu.io/upload_images/15777037-2e56fd3c7a348769.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
2. 序列来创建字典，使用`dict`函数将一个二元元组的列表转化为字典
![](https://upload-images.jianshu.io/upload_images/15777037-46a81dac683ce850.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

使用`del`关键字和`pop`方法删除值（返回值的同时删除键）
![](https://upload-images.jianshu.io/upload_images/15777037-0e09feaebf1e0305.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
使用`update`方法可以将一个字典和另一个融合，该方法改变的是原字典，而非创建个新的字典
![](https://upload-images.jianshu.io/upload_images/15777037-6af68ad6ed0b31b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 如何检查字典是否包含某个键
可以像检查列表和元组是否包含某个值的方法，检查字典中是否包含某个键
![](https://upload-images.jianshu.io/upload_images/15777037-f7e7bcba031fc60b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 字典中keys和values的用法
keys和values是字典的键和值的迭代器方法。虽然键值对没有顺序，这两个方法可以用相同的顺序输出键和值：
![](https://upload-images.jianshu.io/upload_images/15777037-7883d49e27a8db1e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 默认值(字典`setdefault`、`defaultdict`方法的使用)
类似于下面的逻辑
```
if key in some_dict:
    value = some_dict[key]
else
    value = default_value
```

可以使用dict的方法`get`和`pop`取默认值解决，如下
```
value = some_dict.get(key, default_value)
```

`get`默认会返回None,如果不存在键`pop`会抛出异常。
关于设定值，常见的情况是在字典的值是属于其它集合，如列表。例如，你可以通过首字母，将一个列表中的单词分类：

```
In [123]: words = ['apple', 'bat', 'bar', 'atom', 'book']

In [124]: by_letter = {}

In [125]: for word in words:
   .....:     letter = word[0]
   .....:     if letter not in by_letter:
   .....:         by_letter[letter] = [word]
   .....:     else:
   .....:         by_letter[letter].append(word)
   .....:

In [126]: by_letter
Out[126]: {'a': ['apple', 'atom'], 'b': ['bat', 'bar', 'book']}
```
使用`setdefault`方法可以简分上述代码
```
for word in words:
    letter = word[0]
    by_letter.setdefault(letter, []).append(word)
```
collections模块有一个很有用的类，`defaultdict`，它可以进一步简化上面。传递类型或函数以生成每个位置的默认值：
```
from collections import defaultdict
by_letter = defaultdict(list)
for word in words:
    by_letter[word[0]].append(word)
```

#### 字典的键是有类型要求的
字典的值可以是任意的Python对象，而键通常是不可变的标量类型（整数、浮点型、字符串）或元组（元组中的对象必须是不可变的）。这被称为`可哈希性`。可以用`hash`函数检测一个对象是否是可哈希的：
![](https://upload-images.jianshu.io/upload_images/15777037-b58438b6391259d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 集合
集合是一种无序且元素**唯一**的容器(元素必须是不可变的)，两种创建方法：
1. 通过`set`函数
2. 使用大括号
![](https://upload-images.jianshu.io/upload_images/15777037-593334e75560bf12.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
集合支持数学上的集合操作，如联合、交集、差集等
![](https://upload-images.jianshu.io/upload_images/15777037-d5ab657f0adaa094.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
所有的逻辑集合运算都有对应的操作，允许你用操作的结果替换操作左边的集合的内容，这样的作法可以大大提高效率：
![](https://upload-images.jianshu.io/upload_images/15777037-e0c109a98850d3ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 什么时候两个集合相等
只有两个集合的内容一模一样时，两个集合才相等
```
{1，2，3} == {3，2，1}
true
```

#### 列表、字典和集合的推导式
列表推导式就是一个过滤器，它用一种简明的表达式过滤列表中的元素，从而生成一个新的列表，基本表达式：
```
[expr for val in collection if condition]
```

它和下面的for循环是等价的
```
result = []
for val in collection:
    if condition:
        result.append(expr)
```

例题：给定一个字符串列表，过滤出长度大于2的，并且将字母改为大写：
![](https://upload-images.jianshu.io/upload_images/15777037-f6195bb9f71542e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

字典和集合的推导式是列表推导式的自然拓展
字典推导式：
```
dict_comp = {key-expr : value-expr for value in collection              if condition}
```
集合推导式：
```
set_comp = {expr for value in collection if condition}
```

例：有一个字符串列表，我们想要一个所有字符串长度组成的集合
![](https://upload-images.jianshu.io/upload_images/15777037-d7b8de3f3ab3eb6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
上图给出了两个方法，其中使用了`map`函数，下面对该函数做出解释

#### map函数的使用
map()是 Python 内置的高阶函数，它接收一个函数 f 和一个 list，并通过把函数 f 依次作用在 list 的每个元素上，得到一个新的 list 并返回。语法：
```
map(function, iterable, ...)
```

#### 嵌套列表推导式
相当于一个多重循环，例：
```
[name for names in data for name in names if name.count('e')>=2]
```
这样形成的是一个列表，其中for循环部分是根据嵌套的顺序排列的，所有的过滤条件像之前一样被放到尾部
嵌套列表推导式要和列表推导式中的列表推导式区分开。例：
```
[[x for x in tup] for tup in some_tuples]
```
这样形成的是一个包含列表的列表

#### 函数
Python语言中的函数和java中的不同之处在于它有位置参数和关键字参数两种，关键字参数最常用于指定默认值或可选参数。格式如下
```
def func(x,y,z=5):
    if z>1
        return (x+y)
    else
        return z
```
其中x,y为位置参数，z为关键字参数。
>注：关键字参数必须跟在位置参数后面。可以使用关键字参数向位置参数传参，如func(x=1,y=2,z=7)

#### global关键字的用法
global关键字用于声明全局变量，虽然可以在函数中对全局变量进行赋值操作，但是那些变量必须用global关键字声明成全局的才行：
![](https://upload-images.jianshu.io/upload_images/15777037-773c817f8474e90b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
>注：global语句不允许同时进行赋值如`global hehe=3`是不允许的

#### 函数返回多个值
最爱的一个功能，Python的函数可以返回多个值
![](https://upload-images.jianshu.io/upload_images/15777037-14ef90023fe62b80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
其实该函数返回的是一个元组，最后该元组会被拆包到各个结果变量上。因此上述函数的结果可以如下：
![](https://upload-images.jianshu.io/upload_images/15777037-7968fa15053248c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 函数都是对象
在Python中所有函数都是对象，看下面这个平时我们使用函数的方法：
![](https://upload-images.jianshu.io/upload_images/15777037-8661b715ec21a3ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
而在Python中，由于每个函数都是对象，我们可以将函数放到列表中，直接使用列表循环执行多个函数，这时clean_func函数就具有更高的复用性，如下：
![](https://upload-images.jianshu.io/upload_images/15777037-55ded92d3cf97e09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
再比如在`map`函数中是可以将其他函数作为它的参数的，如下
![](https://upload-images.jianshu.io/upload_images/15777037-01486a19c4bbb74b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 匿名（lambda）函数
lambda函数仅由单条语句组成，该语句的结果就是返回值。
```
value = lambda x : x**2
```
该函数会使得数据分析工作更加方便，因为很多数据转换函数都是以函数作为参数的，这时直接传入lambda函数比完整的函数声明要少输入很多字，如下：
![](https://upload-images.jianshu.io/upload_images/15777037-bec655411ea4a360.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
另外一个例子，假如一组字符串，想要根据各字符串不同字母的数量对其进行排序：
![](https://upload-images.jianshu.io/upload_images/15777037-a6052c1b6c9d60af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 什么是柯里化
柯里化指的是将原来接收2个参数的函数变成新的接收一个参数的函数的过程；新的函数返回一个以原有第二个参数作为参数的函数；
例如：将加法函数柯里化过程
```
def add1(x,y):
    return x + y
```
柯里化后：
```
def add2(x): # 通过嵌套函数就可以把函数转换成柯里化函数
    def _add(y):
        return x + y
    return _add

print(add1(1,2)) 
print(add2(1)(2))  #柯里化后的调用
```

#### 什么是迭代器
当你使用for key in some_dict时，Python首先尝试从some_dict创建一个迭代器，迭代器是一种特殊对象，它可以在诸如for循环之类的上下文中向Python解释器输送对象。**大部分接受列表之类的方法都可以接受任何可迭代对象**,如min，max，sum等内置方法以及list、tuple等类型构造器
![](https://upload-images.jianshu.io/upload_images/15777037-ce7694eeb3bf4acd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 什么是生成器
生成器(generator)是构造新的可迭代对象的一种简单方式。一般的函数只会返回单个值，而生成器是以延迟的方式返回一个值序列，即每返回一一个值之后暂停，直到下一个请求时再继续。要创建生成器只需要将函数中的return替换为yeild:
![](https://upload-images.jianshu.io/upload_images/15777037-d1b261756231c039.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
除了通过上述方法来构造生成器外，还可以使用生成器表达器，这是一种类似于列表、字典、集合推导式的生成器。其方式就是把列表推导式两端的方括号变成圆括号：
![](https://upload-images.jianshu.io/upload_images/15777037-dcea0368ca1b199f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### itertools模块
itertools模块中有一组用于常见数据算法的生成器。如groupby可以接受任意序列和一个函数，它可以根据函数的返回值对序列中的连续元素进行分组：
![](https://upload-images.jianshu.io/upload_images/15777037-59325a389262ddb9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### Python中的异常处理
Python中的异常处理方法使用`try/except`，如下：
![](https://upload-images.jianshu.io/upload_images/15777037-e4e91916948ff3d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
只捕捉特定的异常，如下只捕捉`TypeError`：
![](https://upload-images.jianshu.io/upload_images/15777037-52566865154fc83a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
可以使用元组捕捉多个异常，如下：
![](https://upload-images.jianshu.io/upload_images/15777037-79f4d6cf474b84d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
除了`try/except`两个关键字，异常处理还包括`finally/else`
```
f = open(path, 'w')
try:
    write_to_file(f)
except:
    print('Failed')
else:
    print('Succeeded')
finally:
    f.close()
```

#### Python中的文件处理
Python中打开文件的方法，可以使用内置的`open`函数以及一个相对或绝对路径，文件默认是以只读模式('r')打开的，然后我们就可以像处理列表一样处理文件句柄f了：
![](https://upload-images.jianshu.io/upload_images/15777037-e47e0aad67acd834.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
从文件中取出的都是带有完整行结束符（EOL），因此经常会使用以下代码得到一组没有EOL的行(这里将换行符去掉了)：
![](https://upload-images.jianshu.io/upload_images/15777037-9ffce40ef62db3c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
> 注：打开的文件一定要记得使用`f.close`关闭，这样可以返回操作系统资源

python可以使用`with`语句来自动关闭文件：
![](https://upload-images.jianshu.io/upload_images/15777037-8e485f603734f73a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
如果输入`f=open(path,'w')`打开，就会有一个新文件被创建在path的位置下，并且覆盖掉该位置原来的任何数据，，另外有一个x文件模式，它可以创建可写的文件，但是如果文件路径存在，就无法创建，以下列出了所有的读/写模式
![](https://upload-images.jianshu.io/upload_images/15777037-b2c08d1284dfbbdd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 文件管理中read、seek和tell函数
对于可读文件，一些常用的方法是read、seek和tell。`read`会从文件返回字符，字符的内容是由文件的编码决定的（如UTF-8），如果是二进制模式打开的就是原始字节：
![](https://upload-images.jianshu.io/upload_images/15777037-50ba98e12f3c6a7b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
`read`模式会将文件句柄的位置提前，提前的数量是读取的字节数。`tell`可以给出当前的位置
![](https://upload-images.jianshu.io/upload_images/15777037-76d380d58eec9e76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
可以使用`sys`模块检查默认的编码
![](https://upload-images.jianshu.io/upload_images/15777037-1b12e54a7d7b7a6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
`seek`可以将文件位置更改为文件中的指定字节：
![](https://upload-images.jianshu.io/upload_images/15777037-8981f5fc5a774537.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 读取中文文件时报错
当直接使用`read`方法读取中文文件时会出现以下错误`UnicodeDecodeError: ‘gbk’ codec can’t decode byte 0x9d in position 1270: illegal multibyte sequence`，读取中文文件时只能使用二进制模式读取：
![](https://upload-images.jianshu.io/upload_images/15777037-bb17ac3b08001c9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
第二种方法
```
f = open(path,'r',encoding = 'utf-8')
```

#### 文件管理中write和writelines方法
这两个函数用于向文件中写入,这两个函数的区别为：
1. write()需要传入一个字符串做为参数,否则会报错
2. writelines()既可以传入字符串又可以传入一个字符序列,并将该字符序列写入文件

下面给一个例子，假设有一个含有中文及空行的文件，在去除空行后写入另一个文件。
![](https://upload-images.jianshu.io/upload_images/15777037-6caea94e7756fe2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 文件管理中常见方法
![](https://upload-images.jianshu.io/upload_images/15777037-2b41e1020c1b98f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)







