
#### 集合
集合是一种无序且元素**唯一**的容器(元素必须是不可变的)，两种创建方法：
1. 通过`set`函数
2. 使用大括号
![](https://upload-images.jianshu.io/upload_images/15777037-593334e75560bf12.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
集合支持数学上的集合操作，如联合、交集、差集等
![](https://upload-images.jianshu.io/upload_images/15777037-d5ab657f0adaa094.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
所有的逻辑集合运算都有对应的操作，允许你用操作的结果替换操作左边的集合的内容，这样的作法可以大大提高效率：
![](https://upload-images.jianshu.io/upload_images/15777037-e0c109a98850d3ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 什么时候两个集合相等
只有两个集合的内容一模一样时，两个集合才相等
```
{1，2，3} == {3，2，1}
true
```

#### 列表、字典和集合的推导式
列表推导式就是一个过滤器，它用一种简明的表达式过滤列表中的元素，从而生成一个新的列表，基本表达式：
```
[expr for val in collection if condition]
```

它和下面的for循环是等价的
```
result = []
for val in collection:
    if condition:
        result.append(expr)
```

例题：给定一个字符串列表，过滤出长度大于2的，并且将字母改为大写：
![](https://upload-images.jianshu.io/upload_images/15777037-f6195bb9f71542e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

字典和集合的推导式是列表推导式的自然拓展
字典推导式：
```
dict_comp = {key-expr : value-expr for value in collection              if condition}
```
集合推导式：
```
set_comp = {expr for value in collection if condition}
```

例：有一个字符串列表，我们想要一个所有字符串长度组成的集合
![](https://upload-images.jianshu.io/upload_images/15777037-d7b8de3f3ab3eb6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
上图给出了两个方法，其中使用了`map`函数，下面对该函数做出解释

#### map函数的使用
map()是 Python 内置的高阶函数，它接收一个函数 f 和一个 list，并通过把函数 f 依次作用在 list 的每个元素上，得到一个新的 list 并返回。语法：
```
map(function, iterable, ...)
```

#### 嵌套列表推导式
相当于一个多重循环，例：
```
[name for names in data for name in names if name.count('e')>=2]
```
这样形成的是一个列表，其中for循环部分是根据嵌套的顺序排列的，所有的过滤条件像之前一样被放到尾部
嵌套列表推导式要和列表推导式中的列表推导式区分开。例：
```
[[x for x in tup] for tup in some_tuples]
```
这样形成的是一个包含列表的列表

#### 函数
Python语言中的函数和java中的不同之处在于它有位置参数和关键字参数两种，关键字参数最常用于指定默认值或可选参数。格式如下
```
def func(x,y,z=5):
    if z>1
        return (x+y)
    else
        return z
```
其中x,y为位置参数，z为关键字参数。
>注：关键字参数必须跟在位置参数后面。可以使用关键字参数向位置参数传参，如func(x=1,y=2,z=7)

#### global关键字的用法
global关键字用于声明全局变量，虽然可以在函数中对全局变量进行赋值操作，但是那些变量必须用global关键字声明成全局的才行：
![](https://upload-images.jianshu.io/upload_images/15777037-773c817f8474e90b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
>注：global语句不允许同时进行赋值如`global hehe=3`是不允许的

#### 函数返回多个值
最爱的一个功能，Python的函数可以返回多个值
![](https://upload-images.jianshu.io/upload_images/15777037-14ef90023fe62b80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
其实该函数返回的是一个元组，最后该元组会被拆包到各个结果变量上。因此上述函数的结果可以如下：
![](https://upload-images.jianshu.io/upload_images/15777037-7968fa15053248c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 函数都是对象
在Python中所有函数都是对象，看下面这个平时我们使用函数的方法：
![](https://upload-images.jianshu.io/upload_images/15777037-8661b715ec21a3ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
而在Python中，由于每个函数都是对象，我们可以将函数放到列表中，直接使用列表循环执行多个函数，这时clean_func函数就具有更高的复用性，如下：
![](https://upload-images.jianshu.io/upload_images/15777037-55ded92d3cf97e09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
再比如在`map`函数中是可以将其他函数作为它的参数的，如下
![](https://upload-images.jianshu.io/upload_images/15777037-01486a19c4bbb74b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 匿名（lambda）函数
lambda函数仅由单条语句组成，该语句的结果就是返回值。
```
value = lambda x : x**2
```
该函数会使得数据分析工作更加方便，因为很多数据转换函数都是以函数作为参数的，这时直接传入lambda函数比完整的函数声明要少输入很多字，如下：
![](https://upload-images.jianshu.io/upload_images/15777037-bec655411ea4a360.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
另外一个例子，假如一组字符串，想要根据各字符串不同字母的数量对其进行排序：
![](https://upload-images.jianshu.io/upload_images/15777037-a6052c1b6c9d60af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 什么是柯里化
柯里化指的是将原来接收2个参数的函数变成新的接收一个参数的函数的过程；新的函数返回一个以原有第二个参数作为参数的函数；
例如：将加法函数柯里化过程
```
def add1(x,y):
    return x + y
```
柯里化后：
```
def add2(x): # 通过嵌套函数就可以把函数转换成柯里化函数
    def _add(y):
        return x + y
    return _add

print(add1(1,2)) 
print(add2(1)(2))  #柯里化后的调用
```

#### 什么是迭代器
当你使用for key in some_dict时，Python首先尝试从some_dict创建一个迭代器，迭代器是一种特殊对象，它可以在诸如for循环之类的上下文中向Python解释器输送对象。**大部分接受列表之类的方法都可以接受任何可迭代对象**,如min，max，sum等内置方法以及list、tuple等类型构造器
![](https://upload-images.jianshu.io/upload_images/15777037-ce7694eeb3bf4acd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 什么是生成器
生成器(generator)是构造新的可迭代对象的一种简单方式。一般的函数只会返回单个值，而生成器是以延迟的方式返回一个值序列，即每返回一一个值之后暂停，直到下一个请求时再继续。要创建生成器只需要将函数中的return替换为yeild:
![](https://upload-images.jianshu.io/upload_images/15777037-d1b261756231c039.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
除了通过上述方法来构造生成器外，还可以使用生成器表达器，这是一种类似于列表、字典、集合推导式的生成器。其方式就是把列表推导式两端的方括号变成圆括号：
![](https://upload-images.jianshu.io/upload_images/15777037-dcea0368ca1b199f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### itertools模块
itertools模块中有一组用于常见数据算法的生成器。如groupby可以接受任意序列和一个函数，它可以根据函数的返回值对序列中的连续元素进行分组：
![](https://upload-images.jianshu.io/upload_images/15777037-59325a389262ddb9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### Python中的异常处理
Python中的异常处理方法使用`try/except`，如下：
![](https://upload-images.jianshu.io/upload_images/15777037-e4e91916948ff3d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
只捕捉特定的异常，如下只捕捉`TypeError`：
![](https://upload-images.jianshu.io/upload_images/15777037-52566865154fc83a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
可以使用元组捕捉多个异常，如下：
![](https://upload-images.jianshu.io/upload_images/15777037-79f4d6cf474b84d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
除了`try/except`两个关键字，异常处理还包括`finally/else`
```
f = open(path, 'w')
try:
    write_to_file(f)
except:
    print('Failed')
else:
    print('Succeeded')
finally:
    f.close()
```

#### Python中的文件处理
Python中打开文件的方法，可以使用内置的`open`函数以及一个相对或绝对路径，文件默认是以只读模式('r')打开的，然后我们就可以像处理列表一样处理文件句柄f了：
![](https://upload-images.jianshu.io/upload_images/15777037-e47e0aad67acd834.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
从文件中取出的都是带有完整行结束符（EOL），因此经常会使用以下代码得到一组没有EOL的行(这里将换行符去掉了)：
![](https://upload-images.jianshu.io/upload_images/15777037-9ffce40ef62db3c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
> 注：打开的文件一定要记得使用`f.close`关闭，这样可以返回操作系统资源

python可以使用`with`语句来自动关闭文件：
![](https://upload-images.jianshu.io/upload_images/15777037-8e485f603734f73a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
如果输入`f=open(path,'w')`打开，就会有一个新文件被创建在path的位置下，并且覆盖掉该位置原来的任何数据，，另外有一个x文件模式，它可以创建可写的文件，但是如果文件路径存在，就无法创建，以下列出了所有的读/写模式
![](https://upload-images.jianshu.io/upload_images/15777037-b2c08d1284dfbbdd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 文件管理中read、seek和tell函数
对于可读文件，一些常用的方法是read、seek和tell。`read`会从文件返回字符，字符的内容是由文件的编码决定的（如UTF-8），如果是二进制模式打开的就是原始字节：
![](https://upload-images.jianshu.io/upload_images/15777037-50ba98e12f3c6a7b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
`read`模式会将文件句柄的位置提前，提前的数量是读取的字节数。`tell`可以给出当前的位置
![](https://upload-images.jianshu.io/upload_images/15777037-76d380d58eec9e76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
可以使用`sys`模块检查默认的编码
![](https://upload-images.jianshu.io/upload_images/15777037-1b12e54a7d7b7a6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
`seek`可以将文件位置更改为文件中的指定字节：
![](https://upload-images.jianshu.io/upload_images/15777037-8981f5fc5a774537.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 读取中文文件时报错
当直接使用`read`方法读取中文文件时会出现以下错误`UnicodeDecodeError: ‘gbk’ codec can’t decode byte 0x9d in position 1270: illegal multibyte sequence`，读取中文文件时只能使用二进制模式读取：
![](https://upload-images.jianshu.io/upload_images/15777037-bb17ac3b08001c9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
第二种方法
```
f = open(path,'r',encoding = 'utf-8')
```

#### 文件管理中write和writelines方法
这两个函数用于向文件中写入,这两个函数的区别为：
1. write()需要传入一个字符串做为参数,否则会报错
2. writelines()既可以传入字符串又可以传入一个字符序列,并将该字符序列写入文件

下面给一个例子，假设有一个含有中文及空行的文件，在去除空行后写入另一个文件。
![](https://upload-images.jianshu.io/upload_images/15777037-6caea94e7756fe2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 文件管理中常见方法
![](https://upload-images.jianshu.io/upload_images/15777037-2b41e1020c1b98f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)







