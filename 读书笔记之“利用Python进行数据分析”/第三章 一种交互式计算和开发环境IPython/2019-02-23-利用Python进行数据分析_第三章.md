
### 异常和跟踪（相对于Python的*优势*）
使用`%run`命令运行某段脚本时发生异常，Ipython默认会调用整个调用栈跟踪，同时还会附上调用栈各点附近的几行代码作为上下文参考，其中`%xmode`控制上下文代码数量。

### 魔术命令

#### 定义及使用
可以看作运行于IPython系统中的命令行程序，为常用任务提供了便利以及轻松控制IPython系统的行为。大多数都有一些命令行选项，使用`?`可以查看`%reset`命令，如下
```
Docstring:
Resets the namespace by removing all names defined by the user, if
called without arguments, or by removing some types of objects, such
as everything currently in IPython's In[] and Out[] containers (see
the parameters for details).

Parameters
----------
-f : force reset without asking for confirmation.

-s : 'Soft' reset: Only clears your namespace, leaving history intact.
    References to objects may be kept. By default (without this option),
    we do a 'hard' reset, giving you a new session and removing all
    references to objects from the current session.

in : reset input history

out : reset output history

dhist : reset directory history

array : reset only variables that are NumPy arrays

See Also
--------
reset_selective : invoked as ``%reset_selective``

Examples
--------
::

  In [6]: a = 1

  In [7]: a
  Out[7]: 1

  In [8]: 'a' in _ip.user_ns
  Out[8]: True

  In [9]: %reset -f

  In [1]: 'a' in _ip.user_ns
  Out[1]: False

  In [2]: %reset -f in
  Flushing input history

  In [3]: %reset -f dhist in
  Flushing directory history
  Flushing input history

Notes
-----
Calling this magic from clients that do not implement standard input,
such as the ipython notebook interface, will reset the namespace
without confirmation.
File:      c:\users\administrator\appdata\local\programs\python\python37\lib\site-packages\ipython\core\magics\namespace.py
```

#### %run命令
使用该命令可以将所有文件当做Python程序来运行，假如新建一文件untitled.py，如下图
![](https://upload-images.jianshu.io/upload_images/15777037-fb6cc26336483def.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
只要将该文件使用`%run`运行，此后，该文件中所定义所有变量（还有各种import、函数和全局变量）就可以在当前IPython中访问，如下图
![](https://upload-images.jianshu.io/upload_images/15777037-b631e275ac0970d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
如果希望脚本使用IPython命名空间中定义的变量，那就应该使用`%run -i`

#### %automagic
魔术命令一般以百分号`%`为前缀，也可以不使用`%`，只要定义没有与其同名的变量即可，这个技术叫做*automagic*，可以通过`%automagic`打开或关闭

#### %quickref或%magic
访问魔术命令文档

#### %timeit
检测Python语句的执行时间，如下图
![](https://upload-images.jianshu.io/upload_images/15777037-7ba3ee93e46f6bde.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### %reset
删除interactive命名空间中的全部变量/名称，用法如图：
![](https://upload-images.jianshu.io/upload_images/15777037-23852834ab3db43b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### %hist
用于打印命令的输入（输出）历史，可以通过`-f`保存历史记录到文件中，`-n`用于输出选项后指定的某行历史记录

#### %xdel variable
删除variable，并尝试清除其在IPyhton中的对象上的一切引用

#### %load file.py
Jupyter notebook中，可以将脚本文件中的代码块导入到一个代码单元，如下图：
![](https://upload-images.jianshu.io/upload_images/15777037-bd00122e873a9b77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 与matplotlib很好的集成
标准Pyhton shell，当创建绘图窗口时，GUI的事件会循环接管Python会话的控制权，直到绘图窗口关闭，无法实现交互式的数据分析和可视化。而Ipython很好地集成了matplotlib。如图：
![](https://upload-images.jianshu.io/upload_images/15777037-7db05a9ae376e5aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 输入和输出变量
忘记将函数结果赋值给变量，可以通过`_``__`来找回上一个变量和上上一个变量，如图
![](https://upload-images.jianshu.io/upload_images/15777037-be89115e0e367fea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
输入的文本将被保存在`_iX`，其中X为输入行的行号，每个输入变量都有一个对应的输出变量`_X`,如图
![](https://upload-images.jianshu.io/upload_images/15777037-8c771f92d5987e36.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 输入输出历史有关的魔术函数
+ `%hist`显示全部或者部分输入历史记录；
+ `%reset`清空interactive命名空间，并可选择是否清空输入输出缓存
+ `xdel`用于清除Ipython系统中特定对象的一切引用
在处理非常大的数据集的时候，一定要注意IPython的输入输出历史，它会导致所有对象引用都无法被垃圾收集器处理（即释放内存），即使用`del`关键字将变量从interactive命名空间中删除也不行。对于这种情况，谨慎地使用`%xdel`和`%reset`将有助于避免出现内存方面的问题

### 记录输入和输出
IPython能够记录整个控制台会话，执行`%logstart`即可开始记录日志，与之相关的魔术命令`%logoff`、`%logon`、`%logstate`、`%logstop`。

### 与操作系统交互
IPython另一个重要特点就是它和操作系统shell结合非常紧密，可以直接在IPython中使用系统的命令行活动，此外还提供了**shell命令别名**以及**目录书签**等功能.

### shell命令和别名
在IPython中，以感叹号`!`开头的命令行表示其后的所有内容需要在系统shell中执行，甚至还可以启动一个Python解释器（并不是所有的命令行都可以在Jupyter notebook中使用，比如：`!python`就不可以，另外`!cd ..`也无法使用，只有使用`%cd ..`）
可以将shell命令的控制台输出存放的IPython的变量中，它返回的是一个自定义列表，如下图
![](https://upload-images.jianshu.io/upload_images/15777037-b7302c56ec050490.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240
)
同时，在使用`!`时，IPython还允许使用当前环境中定义的Python值，只需要在变量名前面加上`$`符号，如下图
![](https://upload-images.jianshu.io/upload_images/15777037-09987dbce5d92a73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
`%alias`可以为shell命令自定义简称，同时可以一次执行多条命令，只需将它们写在一行上并以**分号**隔开(多条命令在Jupyter notebook中不支持)，如下图
![](https://upload-images.jianshu.io/upload_images/15777037-2870e33f932bcf6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240 )

### 软件开发工具
IPython紧密集成并加强了Python内置的`pdb`调试器，同时还提供了一些简单易用的代码运行时间及性能分析工具。

#### 交互式调试器
IPython的调试器增强了pdb的一些功能：Tab键自动完成、语法高亮、为异常跟踪的每条信息添加上下文参考

#### 事后调试器
在发生异常后，立即执行`%debug`调取‘事后’调试器，可以直接跳转到发生异常的那个栈桢，同时可以通过`u`(或up)和`d`（或down）在各级别的栈跟踪之间切换，如下图
![](https://upload-images.jianshu.io/upload_images/15777037-3231fdebdb44f6d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
在这个调试器，可以运行Python代码并查看各个栈帧中的一切对象和数据。
执行`%pdb on`命令可以将调试器设置为自动开启状态，这样在发生异常的时候可以自动打开。

#### 断点调试
`%run d`进行断点调试，输入`s`（或step）进行单步调试，然后利用`b N`（其中N表示行号）设置断点，再输入`c`(或continue)运行到断点位置，这时可以输入`n`（或next）直接执行到下一行，整个过程可以使用`!`加变量名查看该变量，如下图：
![](https://upload-images.jianshu.io/upload_images/15777037-79ab2b8f77e3f4c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
`h`（或help）可以查看调试器的命令,并且`h`加上相应命令，可以得到命令详情，如下
![](https://upload-images.jianshu.io/upload_images/15777037-78287895f336e821.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 测试代码的执行时间
`%time`和`%timeit`两个命令都是用来测试一条语句的执行时间，不同的是，`%time`一次测试只执行一遍语句，而`%timeit`是对同一语句执行多遍以产生一个平均执行时间，如下图
![](https://upload-images.jianshu.io/upload_images/15777037-56941a288f8afb55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 基本性能分析
代码的性能主要关注的是程序中耗费时间的位置，目前Python性能分析工具是**cProfile**模块，该模块在执行一个程序或代码块时，会记录各个函数耗费的时间。
**启动方式**：通过命令行`python -m cProfile file.py`来执行file.py脚本，执行结果会按照函数名排序，如果加入`pyhton -m cProfile -s cumulative file.py`会按照耗费时间排序。
>注：cProfile模块记录的是各函数从起始到调用结束的时间，不会因为中间调用其他函数而重新计时。

IPython为cProfile提供了接口，通过命令`%prun`或者`%run -p`,通过`%prun`命令启动的工具分析的是Python语句而不是整个.py文件,如下图
![](https://upload-images.jianshu.io/upload_images/15777037-e28fb35760a8fa38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
执行`%run -p -s cumulative file.py`也可以达到上述效果，如下图
![](https://upload-images.jianshu.io/upload_images/15777037-9971289eb18b3fb6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 逐行分析函数性能
一般利用`%prun`（cProfile）做‘宏观的’性能分析，它得到结果要么不足以说明函数的执行时间，要么复杂难懂。因此，可以利用一种名说`line_profiler`的小型库来对一个或多个函数进行逐行性能分析,

#### `line_profiler`如何通过编程的方式使用？
在编程时需要加入修饰符`@profile`，如下

```
@profile
def foo():
    task = []

    for a in range(0, 101):
        for b in range(0, 101):
            if a + b == 100:
                task.append((a, b))
    return task


@profile
def run():
    for item in foo():
        pass


if __name__ == '__main__':
    run()
```

运行下面命令
>kernprof -l -v loopdemo.py

其中，-l表示逐行分析,-v用于输出。同时会输出一个文件:juliademo.py.lprof，后期可以对.lprof文件进行分析。

#### IPython中怎么使用`line_profiler`?
在IPython中的**启动方式**：`%lprun`，想要使用魔术命令`%lprun`有两个引入方法：
1. 修改IPython配置
2. 先导入模块`%load_ext line_profiler`

#### `%prun`和`%lprun`的对比
`%lprun`需要指明测试的哪个或哪些函数，通用的语法为：

```
%lprun -f func1 -f func2 statement_to_profile
```

使用`%prun`和`%lprun`两种命令运行相同函数的效果对比如下：
![](https://upload-images.jianshu.io/upload_images/15777037-1927f04cf2b21d62.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![](https://upload-images.jianshu.io/upload_images/15777037-b984175ec6f698bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
可以看出使用`%prun`得到的结果不能说明什么问题，而`%lprun`的命令结果就容易理解很多了，同时`%lprun`命令可以对多个函数一起测试，效果如下：
![](https://upload-images.jianshu.io/upload_images/15777037-ec359b5e60184af7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

