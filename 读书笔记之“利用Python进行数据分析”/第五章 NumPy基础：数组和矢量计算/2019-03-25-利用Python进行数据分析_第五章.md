### flatten和ravel函数
这两个函数是reshape函数运算过程的相反运算，如下：
![](https://upload-images.jianshu.io/upload_images/15777037-6da9cfffb311fbb1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
flatten和ravel函数的作用是相同的，它们的区别在于，ravel不会产生源数据的副本，它只是返回数组的视图，这样在修改视图的时候会影响原来的数据，而flatten()分配了新的内存，返回了数据的副本，所以我们在平时使用的时候，flatten函数更为安全，具体表现如下：
![](https://upload-images.jianshu.io/upload_images/15777037-9c0d49b0019bc069.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### C和Fortran顺序
行和列优先顺序又分别称为C和Fortran顺序，这里的行和列优行顺序是指数据在内存中的布局顺序。默认情况下，Numpy数组是按行优先顺序创建的。在空间方面，这就意味着，对于一个二维数组，每行中的数据项是被存放在相邻内存位置上的。而列优先顺序，意味着每列中的数据是被存放在相邻内存位置上的。
像reshape和ravel这样的函数，都可以接受一个表示数组数据存放顺序的order参数，一般是`C`或`F`（还有`A`和`K`），具体如下：
![](https://upload-images.jianshu.io/upload_images/15777037-81205c51325e34bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
对于更高维度的数组，C和Fortran顺序的关键就是维度的行进顺序：
* C/行优先顺序：先经过更高的维度（例如：轴1会先于轴0被处理）
* Fortran/列优先顺序：后经过更高的维度（例如：轴0会先于轴1被处理）
![](https://upload-images.jianshu.io/upload_images/15777037-2c5e5d26d0a290aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 转置和轴对换
转置返回的是源数据的视图（不会进行任何复制操作）。数组可以使用`transpose方法`或者`T属性`转置，如下：
![](https://upload-images.jianshu.io/upload_images/15777037-bede51784ee10c7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
`transpose`方法需要得到一个轴编号组成的元组才能对这些轴进行转置，如下：
![](https://upload-images.jianshu.io/upload_images/15777037-29a4904c4efd4eb1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
ndarray还有一个`swapaxes`方法，它需要接受一对轴编号：
![](https://upload-images.jianshu.io/upload_images/15777037-57faf79181aab488.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
`swapaxes`也是返回源数据的视图（不会进行任何复制操作）

### 利用数组进行数据处理
 Numpy数组可以将许多的数据处理任务表述为数组表达式（否则将需要进行编写循环），用数组表达式代替循环的做法通常叫作矢量化。一般来说，矢量化数组运算要比等价的纯Python实现快上一两个数量级。
 例如想要在一组值（网格型）上计算sqrt(x^2+y^2),可通过以下矢量运算来实现：
 ![](https://upload-images.jianshu.io/upload_images/15777037-75d086923cd37a13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
 ![](https://upload-images.jianshu.io/upload_images/15777037-8a8b85b39d8c1182.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### numpy.where函数的使用
` numpy.where`函数是`x if condition else y`的矢量化版本。
假设我们想要根据cond中的值选取xarr和yarr的值：当cond中的值为True时，选取xarr的值，否则从yarr中选取，列表推导式的写法如下：
![](https://upload-images.jianshu.io/upload_images/15777037-468fc1f8efc06b48.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
这里存在几个问题：
1. 它对大数组的处理速度慢
2. 无法用于多维数组

为解决以上问题，我们使用numpy.where，如下：
![](https://upload-images.jianshu.io/upload_images/15777037-7edf35ee5370cd8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
其中numpy.where中的第二和第三个参数不必是数组，也可以是标量值。在数据分析中，where通常的用法是：
![](https://upload-images.jianshu.io/upload_images/15777037-5284c9271f92542b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
传递给where的数组大小可以不相等。
来个有难度的逻辑，有两个布尔型数组cond1和cond2，进行如下操作 :
```python
result = []
for i in range(n):
    if cond1[i] and cond2[i]:
        result.append(0)
    elif cond1[i]:
        result.append(1)
    elif cond2[i]:
        result.append(2)
    else:
        rsult.append(3)
```

我们可以使用where来代替上述代码：
```python
np.where(cond1 & cond2, 0, 
    np.where(cond1,1,
        np.where(cond2, 2, 3)))
```

### 通用函数：快速的元素级数组函数
通用函数是一对ndarray中的数据执行元素级运算的函数。可以将它作为简单函数的矢量化包装器。它包括一元的：
![](https://upload-images.jianshu.io/upload_images/15777037-ac6ecbbf99b318e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
二元，返回一个结果数组的：
![](https://upload-images.jianshu.io/upload_images/15777037-452de5ac35b63315.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
返回多个数组的：
![](https://upload-images.jianshu.io/upload_images/15777037-838d02a7b1330ca5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
通用函数可以接受一个out可选参数，这样就能在数组原地进行操作：
![](https://upload-images.jianshu.io/upload_images/15777037-8b6da5f74036c165.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
下表列出了一些一元和二元通用函数
![](https://upload-images.jianshu.io/upload_images/15777037-fa8cbcbc9d6c9be7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![](https://upload-images.jianshu.io/upload_images/15777037-a44c7d1c616f9b04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![](https://upload-images.jianshu.io/upload_images/15777037-ac3bd85f241d6bb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 数学和统计方法
Numpy提供了一组数学函数来对整个数组或者某个轴向的数据进行统计计算。sum、mean以及std等`聚合计算`既可以做为数组的实例方法调用，也可以当做顶级Numpy函数使用，如下：
![](https://upload-images.jianshu.io/upload_images/15777037-3d5c3c5d432fb1ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
同时，mean和sum这类函数可以接受一个axis选项参数，用于计算该轴向上的统计值，最终结果是一个少一维的数组：
![](https://upload-images.jianshu.io/upload_images/15777037-93d4f318f19243b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
`累加函数`返回的则是同样大小的数组，但会根据每个低维的切片沿着标记轴计算部分聚类：
![](https://upload-images.jianshu.io/upload_images/15777037-ece5d103d6344d21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
下面列出了全部的基本数组统计方法：
![](https://upload-images.jianshu.io/upload_images/15777037-93f5fd51c59940c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![](https://upload-images.jianshu.io/upload_images/15777037-9193661a1ae65d88.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 布尔型数组的方法(any,all)
布尔值会被强制转换为1(True)和0(False)。因此，sum经常被用来对布尔型数组中的True值计数：
![](https://upload-images.jianshu.io/upload_images/15777037-e7de4e5c78575039.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
同时，数组还有两个方法`any`和`all`，它们对布尔型数组非常有用。any用于测试数组中是否存在True，而all则检查数组中所有值是否都是True，这两个方法也能用于非布尔数组，所有非0元素将会被当做True

### Numpy中的sort方法
Numpy中也有`sort`方法来就地排序：
![](https://upload-images.jianshu.io/upload_images/15777037-de196a586f07817c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
同时，它也支持轴向参数，来对特定轴向进行排序
![](https://upload-images.jianshu.io/upload_images/15777037-b79950b457a16138.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
顶级方法np.sort返回的是数组的已排序副本，而就地排序则会修改数组本身，计算数组分位数最简单的办法是对其进行排序，然后选取特定位置的值：
![](https://upload-images.jianshu.io/upload_images/15777037-777b0edcafc9414c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 针对一维ndarray其他的集合逻辑（unique、in1d等）
Numpy提供了一些针对`一维ndarray`的基本集合运算。最常用的要数np.unique了，它可以找出数组中唯一值并返回已排序的结果：
![](https://upload-images.jianshu.io/upload_images/15777037-7bc14b39a5f4bfcc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
与上述代码等价的python代码：
![](https://upload-images.jianshu.io/upload_images/15777037-9c07e1dbfd522fd3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
另一个函数np.in1d用于测试一个数组中的值在另一个数组中的成员资格，返回一个布尔型数组：
![](https://upload-images.jianshu.io/upload_images/15777037-f6750814ada60eab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
Numpy中的集合函数如下表：
![](https://upload-images.jianshu.io/upload_images/15777037-6c355ede5c96372c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 将数组以二进制格式保存在磁盘
np.save和np.load是读写磁盘数组数据的两个主要函数。默认情况下，数组是以未压缩的原始二进制格式保存在扩展名为.npy的文件中的。
![](https://upload-images.jianshu.io/upload_images/15777037-a70e4fc8a00c8169.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
如果文件路径末尾没有扩展名.npy，则该扩展名会被自动加上。然后就可以通过np.load读取磁盘上的数组
![](https://upload-images.jianshu.io/upload_images/15777037-5f8a50ebdace8ddd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
可以使用np.savez将多个数组保存到一个压缩文件中，将数组以关键字参数的形式传入即可
![](https://upload-images.jianshu.io/upload_images/15777037-d6e44c62591aef18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
加载.npz文件时，会得到一个类似字典的对象，该对象会对各个数组进行延迟加载
![](https://upload-images.jianshu.io/upload_images/15777037-7674b055754c8a2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 将数组读写到文本文件中
Numpy中用于加载文本文件的函数为numpy.loadtxt和numpy.genfromtxt。这些函数有很多的选项可供使用：指定各种分隔符、针对特定列的转换器函数、需要跳过的行数等，下面以简单的逗号分隔符为例 ：
![](https://upload-images.jianshu.io/upload_images/15777037-2c0ce074161a16a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![](https://upload-images.jianshu.io/upload_images/15777037-2b6a5378d6431d21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
numpy.savetxt执行的相反的操作：将数组数据写到以某种分隔符隔开的文本文件中，
![](https://upload-images.jianshu.io/upload_images/15777037-ac4901e01c6f3f0f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
genfromtxt跟loadtxt差不多，只不过它面向的是结构化数组和缺失数据处理

### 结构化和记录式数组
ndarray是一种同质数据容器，也就是说它表示的内存块中，各元素占用的字节数相同（具体根据dtype而定）。结构化数组是一种特殊的ndarray，其中的各个元素可以被看做C语言的结构体(struct，这也是“结构化”的由来)或SQL表中带有多个字段的行：
![](https://upload-images.jianshu.io/upload_images/15777037-a89c115fe98672fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
定义结构化dtype的方法有很多，最典型的方法是元组列表，各无组的格式为(field_name, field_data_type)。这样数组的元素就成了元组式的对象，该对象中各个元素可以像字典那样进行访问：
![](https://upload-images.jianshu.io/upload_images/15777037-8012db4679b08068.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
字段名保存在dtype.names属性中。在访问结构化数组的某个字段时，返回的是该数据的视图，所以不会发生数据复制:
![](https://upload-images.jianshu.io/upload_images/15777037-b96442eccaf9786d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 嵌套dtype和多维字段
在定义结构化dtype时，可以再设置一个形状（可以是一个整数，也可以是一个元组）：
![](https://upload-images.jianshu.io/upload_images/15777037-0e8e2ad674d8ebc4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
在这个情况下，各个记录的x字段所表示的是一个长度为3的数组：
![](https://upload-images.jianshu.io/upload_images/15777037-6522f50464d57184.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
直接访问arr['x']可以得到一个二维数组：
![](https://upload-images.jianshu.io/upload_images/15777037-cda817efeb04e773.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
> 注：dtype中还可以再次嵌套dtype

### 为什么要使用结构化数组
跟pandas的DataFrame相比，Numpy的结构化数组是一个相对较低级的工具。它可以将单个内存块解释为带有任意复杂嵌套的表格型结构。由于数组中的每个元素在内存中都表示为`固定的字节数`，所以结构化数组能够提供非常`快速高效`的磁盘数据读写、网络传输等功能。
结构化数组另一个比较常见的用法：将数据文件写成定长记录字节流，这是C和C++代码中常见的数据序列化手段。只要知道文件的格式，就可以用numpy.fromfile将数据读入内存。

### 矩阵点积的三种方法
1. x.dot(y)
2. np.dot(x, y)
3. 使用中缀运算符`@`, x @ np.ons(3)如下：
![](https://upload-images.jianshu.io/upload_images/15777037-7beb1b88dc2f7e48.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### numpy.linalg库
nympy.linalg中有一组标准的矩阵分解运算以及诸如求逆和行列式之类的东西。它们跟Matlab和R语言使用的是相同的行业标准线性代数库，如BLAS、LAPACK、IntelMKL等：
![](https://upload-images.jianshu.io/upload_images/15777037-976a8f5d1e8188fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
下表给出一些常用的numpy.linalg函数
![](https://upload-images.jianshu.io/upload_images/15777037-9943bacb2a82643f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

