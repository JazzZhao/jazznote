
### Numpy的切片
Numpy的索引是一个内容丰富的主题。当你将一个标量赋值给一个切片时（如arr[5:8]=12），该值会自动传播（也就是广播）到整个选区。跟列表的重要区别在于，数组切片是原始数组的视图，这意味着数据不会被复制，视图上的任何修改都会直接反映到源数组上。

> 注：Numpy的切片是在原数据上进行修改，未复制新数据

![](https://upload-images.jianshu.io/upload_images/15777037-060f4b18180618d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
如果想获得一份数组切片的拷贝，可以使用arr[5:8].copy()

### 高维数组如何获取单个元素
两种方式，
1. 对各个元素进行递归访问;
2. 传到一个用逗号隔开的索引列表
![](https://upload-images.jianshu.io/upload_images/15777037-8caa3aa149bef36d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 高维数组如何获得低维度数组以及赋值
在多维数组中，如果省略后面的索引，则返回对象会是一个维度低一点的ndarray。因此,在2 * 2 * 3数组arr中
![](https://upload-images.jianshu.io/upload_images/15777037-b4dde55dd16da8cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
arr[0]是一个2*3数组
![](https://upload-images.jianshu.io/upload_images/15777037-81243d81e9f490c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
标量值和数组都可以赋值给arr[0]：
![](https://upload-images.jianshu.io/upload_images/15777037-1343a0f27cd60a87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
> 注：在上述这些选取子集的例子中，返回的数组都是视图

### 高维度的切片索引
对于一维数组来说，其切片语法跟Python列表差不多：
![](https://upload-images.jianshu.io/upload_images/15777037-2a244e5d2ae85829.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
而对于二维数组来说，其切片方式就略有不同：
![](https://upload-images.jianshu.io/upload_images/15777037-f02dc11aef097268.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
可以看出，它是沿着0轴（即第一个轴）切片的。也就是说，切片就是沿着一个轴向选取元素的。表达示array[:2]可以被认为是选取了array的前两行。
你也可以一次传入多个切片，像传入多个索引那样：
![](https://upload-images.jianshu.io/upload_images/15777037-52c25a58af61842f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
我们也可以将索引和切片相结合使用，如我们选取第二行的前两列：
![](https://upload-images.jianshu.io/upload_images/15777037-64d59d3709ecbbf8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
下图有助于理解切片：
![](https://upload-images.jianshu.io/upload_images/15777037-ffcc63c7a547e8f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 布尔型索引
假设我们有一个存储数据和存储姓名的数组，如下：
![](https://upload-images.jianshu.io/upload_images/15777037-66db691effff8d7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
假设每个名字都对应datas数组中的一列，而我们想选出对应于名字‘zhao’的所有列。跟算术运算一样，数组的比较运算'=='也是矢量化的。因此names和字符串'zhao'的比较运算将会产生一个布尔型数组：
![](https://upload-images.jianshu.io/upload_images/15777037-4bee66cce13a76f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
该布尔型数组可以用于数组索引：
![](https://upload-images.jianshu.io/upload_images/15777037-85ede40f291878c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

> 注：布尔型数组的长度必须要与被索引的轴长度一致

此外，还可以将布尔型数组跟切片、整数（或整数序列）混合使用。
要选择除‘zhao’以外的其他值，可以使用不等号‘!=’或者使用`~`对条件进行否定：
![](https://upload-images.jianshu.io/upload_images/15777037-2c3119b811acc02f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
要想组合多个布尔型数组，可以使用`&`和`|`或之类的布尔算术运算即可：
![](https://upload-images.jianshu.io/upload_images/15777037-1ec27d67fb630341.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

> 注：Python关键字and和or在布尔型数组中无效。要使用`&`和`|`

使用布尔型数组设置值是一种很常见的用法，例如将所有小于0的数值都设置为0，就可以使用布尔型数组进行设置。

### 花式索引
花式索引是Numpy中的术语，用于描述使用整数数组进行数据索引。意思是：使用一个包含指明所需顺序的列表或数组，从某一个数组中选出一个符合特定顺序的子集。如下：
![](https://upload-images.jianshu.io/upload_images/15777037-fc55e9060dbf41d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
使用负的索引则是从尾部进行选择。
当传递多个索引数组时则是根据每个索引元组对应的元素选出一个一维数组：
![](https://upload-images.jianshu.io/upload_images/15777037-65a95827b83c1ec9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
可以看出最终选出的元素是(4,1),(2,2),(1,3),(5,1)
如果想要达到排序的效果，应该是矩形区域的形式才对，如上图的方法
> 记住，花式索引跟切片不一样，它总是将数据复制到新数组中。

### reshape函数
1. 将原数组从一个形状转换为另一个形状
2. 传入的参数是`元组`
如下：
![](https://upload-images.jianshu.io/upload_images/15777037-699e8c7eef27f908.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
其中参数可以为`-1`，它表示该维充的大小由数据本身推断而来
![](https://upload-images.jianshu.io/upload_images/15777037-7b71cd2d76b6c75f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
由于数组的shape是一个元组，所以它也可以传入reshape

### flatten和ravel函数
这两个函数是reshape函数运算过程的相反运算，如下：
![](https://upload-images.jianshu.io/upload_images/15777037-6da9cfffb311fbb1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
flatten和ravel函数的作用是相同的，它们的区别在于，ravel不会产生源数据的副本，它只是返回数组的视图，这样在修改视图的时候会影响原来的数据，而flatten()分配了新的内存，返回了数据的副本，所以我们在平时使用的时候，flatten函数更为安全，具体表现如下：
![](https://upload-images.jianshu.io/upload_images/15777037-9c0d49b0019bc069.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### C和Fortran顺序
行和列优先顺序又分别称为C和Fortran顺序，这里的行和列优行顺序是指数据在内存中的布局顺序。默认情况下，Numpy数组是按行优先顺序创建的。在空间方面，这就意味着，对于一个二维数组，每行中的数据项是被存放在相邻内存位置上的。而列优先顺序，意味着每列中的数据是被存放在相邻内存位置上的。
像reshape和ravel这样的函数，都可以接受一个表示数组数据存放顺序的order参数，一般是`C`或`F`（还有`A`和`K`），具体如下：
![](https://upload-images.jianshu.io/upload_images/15777037-81205c51325e34bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
对于更高维度的数组，C和Fortran顺序的关键就是维度的行进顺序：
* C/行优先顺序：先经过更高的维度（例如：轴1会先于轴0被处理）
* Fortran/列优先顺序：后经过更高的维度（例如：轴0会先于轴1被处理）
![](https://upload-images.jianshu.io/upload_images/15777037-2c5e5d26d0a290aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 转置和轴对换
转置返回的是源数据的视图（不会进行任何复制操作）。数组可以使用`transpose方法`或者`T属性`转置，如下：
![](https://upload-images.jianshu.io/upload_images/15777037-bede51784ee10c7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
`transpose`方法需要得到一个轴编号组成的元组才能对这些轴进行转置，如下：
![](https://upload-images.jianshu.io/upload_images/15777037-29a4904c4efd4eb1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
ndarray还有一个`swapaxes`方法，它需要接受一对轴编号：
![](https://upload-images.jianshu.io/upload_images/15777037-57faf79181aab488.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
`swapaxes`也是返回源数据的视图（不会进行任何复制操作）

### 利用数组进行数据处理
 Numpy数组可以将许多的数据处理任务表述为数组表达式（否则将需要进行编写循环），用数组表达式代替循环的做法通常叫作矢量化。一般来说，矢量化数组运算要比等价的纯Python实现快上一两个数量级。
 例如想要在一组值（网格型）上计算sqrt(x^2+y^2),可通过以下矢量运算来实现：
 ![](https://upload-images.jianshu.io/upload_images/15777037-75d086923cd37a13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
 ![](https://upload-images.jianshu.io/upload_images/15777037-8a8b85b39d8c1182.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### numpy.where函数的使用
` numpy.where`函数是`x if condition else y`的矢量化版本。
假设我们想要根据cond中的值选取xarr和yarr的值：当cond中的值为True时，选取xarr的值，否则从yarr中选取，列表推导式的写法如下：
![](https://upload-images.jianshu.io/upload_images/15777037-468fc1f8efc06b48.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
这里存在几个问题：
1. 它对大数组的处理速度慢
2. 无法用于多维数组

为解决以上问题，我们使用numpy.where，如下：
![](https://upload-images.jianshu.io/upload_images/15777037-7edf35ee5370cd8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
其中numpy.where中的第二和第三个参数不必是数组，也可以是标量值。在数据分析中，where通常的用法是：
![](https://upload-images.jianshu.io/upload_images/15777037-5284c9271f92542b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
传递给where的数组大小可以不相等。
来个有难度的逻辑，有两个布尔型数组cond1和cond2，进行如下操作 :
```python
result = []
for i in range(n):
    if cond1[i] and cond2[i]:
        result.append(0)
    elif cond1[i]:
        result.append(1)
    elif cond2[i]:
        result.append(2)
    else:
        rsult.append(3)
```

我们可以使用where来代替上述代码：
```python
np.where(cond1 & cond2, 0, 
    np.where(cond1,1,
        np.where(cond2, 2, 3)))
```

### 通用函数：快速的元素级数组函数
通用函数是一对ndarray中的数据执行元素级运算的函数。可以将它作为简单函数的矢量化包装器。它包括一元的：
![](https://upload-images.jianshu.io/upload_images/15777037-ac6ecbbf99b318e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
二元，返回一个结果数组的：
![](https://upload-images.jianshu.io/upload_images/15777037-452de5ac35b63315.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
返回多个数组的：
![](https://upload-images.jianshu.io/upload_images/15777037-838d02a7b1330ca5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
通用函数可以接受一个out可选参数，这样就能在数组原地进行操作：
![](https://upload-images.jianshu.io/upload_images/15777037-8b6da5f74036c165.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
下表列出了一些一元和二元通用函数
![](https://upload-images.jianshu.io/upload_images/15777037-fa8cbcbc9d6c9be7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![](https://upload-images.jianshu.io/upload_images/15777037-a44c7d1c616f9b04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![](https://upload-images.jianshu.io/upload_images/15777037-ac3bd85f241d6bb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 数学和统计方法
Numpy提供了一组数学函数来对整个数组或者某个轴向的数据进行统计计算。sum、mean以及std等`聚合计算`既可以做为数组的实例方法调用，也可以当做顶级Numpy函数使用，如下：
![](https://upload-images.jianshu.io/upload_images/15777037-3d5c3c5d432fb1ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
同时，mean和sum这类函数可以接受一个axis选项参数，用于计算该轴向上的统计值，最终结果是一个少一维的数组：
![](https://upload-images.jianshu.io/upload_images/15777037-93d4f318f19243b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
`累加函数`返回的则是同样大小的数组，但会根据每个低维的切片沿着标记轴计算部分聚类：
![](https://upload-images.jianshu.io/upload_images/15777037-ece5d103d6344d21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
下面列出了全部的基本数组统计方法：
![](https://upload-images.jianshu.io/upload_images/15777037-93f5fd51c59940c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![](https://upload-images.jianshu.io/upload_images/15777037-9193661a1ae65d88.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 布尔型数组的方法(any,all)
布尔值会被强制转换为1(True)和0(False)。因此，sum经常被用来对布尔型数组中的True值计数：
![](https://upload-images.jianshu.io/upload_images/15777037-e7de4e5c78575039.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
同时，数组还有两个方法`any`和`all`，它们对布尔型数组非常有用。any用于测试数组中是否存在True，而all则检查数组中所有值是否都是True，这两个方法也能用于非布尔数组，所有非0元素将会被当做True

### Numpy中的sort方法
Numpy中也有`sort`方法来就地排序：
![](https://upload-images.jianshu.io/upload_images/15777037-de196a586f07817c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
同时，它也支持轴向参数，来对特定轴向进行排序
![](https://upload-images.jianshu.io/upload_images/15777037-b79950b457a16138.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
顶级方法np.sort返回的是数组的已排序副本，而就地排序则会修改数组本身，计算数组分位数最简单的办法是对其进行排序，然后选取特定位置的值：
![](https://upload-images.jianshu.io/upload_images/15777037-777b0edcafc9414c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 针对一维ndarray其他的集合逻辑（unique、in1d等）
Numpy提供了一些针对`一维ndarray`的基本集合运算。最常用的要数np.unique了，它可以找出数组中唯一值并返回已排序的结果：
![](https://upload-images.jianshu.io/upload_images/15777037-7bc14b39a5f4bfcc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
与上述代码等价的python代码：
![](https://upload-images.jianshu.io/upload_images/15777037-9c07e1dbfd522fd3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
另一个函数np.in1d用于测试一个数组中的值在另一个数组中的成员资格，返回一个布尔型数组：
![](https://upload-images.jianshu.io/upload_images/15777037-f6750814ada60eab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
Numpy中的集合函数如下表：
![](https://upload-images.jianshu.io/upload_images/15777037-6c355ede5c96372c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 将数组以二进制格式保存在磁盘
np.save和np.load是读写磁盘数组数据的两个主要函数。默认情况下，数组是以未压缩的原始二进制格式保存在扩展名为.npy的文件中的。
![](https://upload-images.jianshu.io/upload_images/15777037-a70e4fc8a00c8169.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
如果文件路径末尾没有扩展名.npy，则该扩展名会被自动加上。然后就可以通过np.load读取磁盘上的数组
![](https://upload-images.jianshu.io/upload_images/15777037-5f8a50ebdace8ddd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
可以使用np.savez将多个数组保存到一个压缩文件中，将数组以关键字参数的形式传入即可
![](https://upload-images.jianshu.io/upload_images/15777037-d6e44c62591aef18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
加载.npz文件时，会得到一个类似字典的对象，该对象会对各个数组进行延迟加载
![](https://upload-images.jianshu.io/upload_images/15777037-7674b055754c8a2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 将数组读写到文本文件中
Numpy中用于加载文本文件的函数为numpy.loadtxt和numpy.genfromtxt。这些函数有很多的选项可供使用：指定各种分隔符、针对特定列的转换器函数、需要跳过的行数等，下面以简单的逗号分隔符为例 ：
![](https://upload-images.jianshu.io/upload_images/15777037-2c0ce074161a16a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![](https://upload-images.jianshu.io/upload_images/15777037-2b6a5378d6431d21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
numpy.savetxt执行的相反的操作：将数组数据写到以某种分隔符隔开的文本文件中，
![](https://upload-images.jianshu.io/upload_images/15777037-ac4901e01c6f3f0f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
genfromtxt跟loadtxt差不多，只不过它面向的是结构化数组和缺失数据处理

### 结构化和记录式数组
ndarray是一种同质数据容器，也就是说它表示的内存块中，各元素占用的字节数相同（具体根据dtype而定）。结构化数组是一种特殊的ndarray，其中的各个元素可以被看做C语言的结构体(struct，这也是“结构化”的由来)或SQL表中带有多个字段的行：
![](https://upload-images.jianshu.io/upload_images/15777037-a89c115fe98672fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
定义结构化dtype的方法有很多，最典型的方法是元组列表，各无组的格式为(field_name, field_data_type)。这样数组的元素就成了元组式的对象，该对象中各个元素可以像字典那样进行访问：
![](https://upload-images.jianshu.io/upload_images/15777037-8012db4679b08068.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
字段名保存在dtype.names属性中。在访问结构化数组的某个字段时，返回的是该数据的视图，所以不会发生数据复制:
![](https://upload-images.jianshu.io/upload_images/15777037-b96442eccaf9786d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 嵌套dtype和多维字段
在定义结构化dtype时，可以再设置一个形状（可以是一个整数，也可以是一个元组）：
![](https://upload-images.jianshu.io/upload_images/15777037-0e8e2ad674d8ebc4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
在这个情况下，各个记录的x字段所表示的是一个长度为3的数组：
![](https://upload-images.jianshu.io/upload_images/15777037-6522f50464d57184.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
直接访问arr['x']可以得到一个二维数组：
![](https://upload-images.jianshu.io/upload_images/15777037-cda817efeb04e773.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
> 注：dtype中还可以再次嵌套dtype

### 为什么要使用结构化数组
跟pandas的DataFrame相比，Numpy的结构化数组是一个相对较低级的工具。它可以将单个内存块解释为带有任意复杂嵌套的表格型结构。由于数组中的每个元素在内存中都表示为`固定的字节数`，所以结构化数组能够提供非常`快速高效`的磁盘数据读写、网络传输等功能。
结构化数组另一个比较常见的用法：将数据文件写成定长记录字节流，这是C和C++代码中常见的数据序列化手段。只要知道文件的格式，就可以用numpy.fromfile将数据读入内存。

### 矩阵点积的三种方法
1. x.dot(y)
2. np.dot(x, y)
3. 使用中缀运算符`@`, x @ np.ons(3)如下：
![](https://upload-images.jianshu.io/upload_images/15777037-7beb1b88dc2f7e48.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### numpy.linalg库
nympy.linalg中有一组标准的矩阵分解运算以及诸如求逆和行列式之类的东西。它们跟Matlab和R语言使用的是相同的行业标准线性代数库，如BLAS、LAPACK、IntelMKL等：
![](https://upload-images.jianshu.io/upload_images/15777037-976a8f5d1e8188fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
下表给出一些常用的numpy.linalg函数
![](https://upload-images.jianshu.io/upload_images/15777037-9943bacb2a82643f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 伪随机数生成
numpy.random模块对Python内置的random进行了补充，增加了一些用于高效生成`多种概率分布`的样本值的函数。如下：


```python
samples = np.random.normal(size = (4,4))
```


```python
samples
```




    array([[ 0.79575632,  0.6952795 , -0.4667241 , -0.35462315],
           [-0.79189604, -0.04394413,  0.10390778, -1.18859107],
           [ 0.12606027,  0.73113933,  0.33346507, -0.29562742],
           [-2.06527112,  0.83437652,  0.08950446, -0.21639724]])



而Python内置的random一次只能生成一个样本值。下面对两种方法进行性能测试，可以看出，如果需要产生大量样本值，numpy.random快了不止一个数量级：


```python
from random import normalvariate

N = 1000000
```


```python
%timeit samples = [normalvariate(0,1) for _ in range(N)]
```

    2.14 s ± 118 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
    


```python
%timeit np.random.normal(size = N)
```

    64.4 ms ± 6.77 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
    

之所以这些都是伪随机数，是因为它们都是通过算法基于随机数生成器种子，在确定性的条件下生成的。我们可以通过numpy.random.seed更改随机数生成种子：


```python
np.random.seed(1234)
```

numpy.random的数据生成函数使用了全局的随机种子。要避免全局状态，可以使用numpy.random.RandomState，创建一个与其他隔离的随机数生成器：


```python
myrand = np.random.RandomState(1234)
```


```python
myrand.randn(10)
```




    array([ 0.47143516, -1.19097569,  1.43270697, -0.3126519 , -0.72058873,
            0.88716294,  0.85958841, -0.6365235 ,  0.01569637, -2.24268495])


下面列出numpy.random中的部分函数：
![](https://upload-images.jianshu.io/upload_images/15777037-27e056e10e7abb49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![](https://upload-images.jianshu.io/upload_images/15777037-27fa99d66a938e95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 随机漫步
下面通过内置的`random`模块以纯Python的方式实现1000步的随机漫步：


```python
import numpy as np

import matplotlib.pyplot as plt

import random

position = 0
walk = [position]
steps = 1000;
for i in range(steps):
    step = 1 if random.randint(0,1) else -1
    position += step
    walk.append(position)

plt.plot(walk[:100])
```




    [<matplotlib.lines.Line2D at 0xe79b0b8>]




![png](https://upload-images.jianshu.io/upload_images/15777037-eb3f685fe0a4790e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


不难看出，这其实是随机漫步中各步的累计和，可以用一个数组运算来实现，这里用np.random模块一次性随机产生1000个“掷硬币”结果，将其分别设置为1或-1,然后累计和：


```python
nstep = 1000

draws = np.random.randint(0,2, size = nstep)

steps = np.where(draws>0, 1, -1)

walk = np.cumsum(steps)
```

有了这些数据，就可以沿着漫步路径做一些统计工作了，比如求最大值和最小值


```python
walk.min()
```




    -50




```python
walk.max()
```




    7


